# Feature: Pinned Messages

## Overview
Add the ability for any user to pin/unpin messages in a channel, and view all pinned messages for the current channel via a list accessible from the channel header. This is a core Phase 4 feature from PLAN.md.

## What to Build

### 1. Schema Change â€” `convex/schema.ts`

Add a `pinnedMessages` table to track which messages are pinned and by whom:

```typescript
pinnedMessages: defineTable({
  messageId: v.id("messages"),
  channelId: v.id("channels"),
  pinnedBy: v.id("users"),
  pinnedAt: v.number(),
})
  .index("by_channelId", ["channelId"])
  .index("by_messageId", ["messageId"]),
```

After editing the schema, run `pnpm -s convex codegen` to regenerate types.

### 2. Backend â€” `convex/pins.ts` (new file)

Create a new Convex file with these functions:

**`pinMessage` (mutation)**
- Args: `messageId: v.id("messages")`, `userId: v.id("users")`
- Validate the message exists
- Check if already pinned (query `by_messageId` index) â€” if so, return early / throw
- Insert into `pinnedMessages` with `channelId` from the message, `pinnedBy: userId`, `pinnedAt: Date.now()`

**`unpinMessage` (mutation)**
- Args: `messageId: v.id("messages")`, `userId: v.id("users")`
- Find the pin record by `messageId` index, delete it
- If not found, return early

**`getPinnedMessages` (query)**
- Args: `channelId: v.id("channels")`
- Query `pinnedMessages` by `by_channelId` index
- For each pin, fetch the message and the message's user (using `Promise.all` for parallel fetches)
- Also fetch reactions for each pinned message (same pattern as `getMessages` in `messages.ts`)
- Filter out any pins where the message was deleted (message is null)
- Return array of `{ pin, message, user, reactions }` sorted by `pinnedAt` descending (newest pins first)

**`getPinStatus` (query)**
- Args: `messageId: v.id("messages")`
- Query `pinnedMessages` by `by_messageId` index
- Return `{ isPinned: boolean, pinnedBy?: string }` â€” include the pinner's username if pinned

### 3. Frontend â€” Pin Button in `MessageItem.tsx`

In the hover toolbar (the `hoverToolbar` variable around line 158), add a pin/unpin button:

- Add a ðŸ“Œ button in the toolbar between the thread reply button and the edit button
- The button should call `pinMessage` or `unpinMessage` depending on current pin state
- To get pin status: use `useQuery(api.pins.getPinStatus, { messageId: message._id })` â€” but this would be expensive to call per message. Instead, **pass pin status down from the message list**.

**Better approach for pin status:**
- In `MessageList.tsx`, call `useQuery(api.pins.getPinnedMessages, { channelId })` to get all pinned message IDs for the channel
- Create a `Set` of pinned message IDs and pass `isPinned` as a prop to each `MessageItem`
- In `MessageItem`, show ðŸ“Œ icon (filled/active) if pinned, and change the button action accordingly

**Pin indicator on the message itself:**
- When a message is pinned, show a small "ðŸ“Œ Pinned" label below the username/timestamp line (visible even when not hovering)
- Style it subtly: `text-xs text-amber-500/70`

### 4. Frontend â€” Pinned Messages List Panel

Create a new component `src/components/PinnedMessages.tsx`:

- Receives `channelId` as a prop, and an `onClose` callback
- Uses `useQuery(api.pins.getPinnedMessages, { channelId })` to get pinned messages
- Renders a panel (same width/style as `ThreadPanel` â€” `w-80`, dark background with border)
- Header: "ðŸ“Œ Pinned Messages" with a close (Ã—) button
- Body: scrollable list of pinned messages, each showing:
  - The message author's avatar, username, and timestamp
  - The message text (rendered with `<MessageText>`)
  - An "Unpin" button
  - A "Jump to message" button (stretch goal â€” can skip for now)
- Empty state: "No pinned messages in this channel"

### 5. Frontend â€” Channel Header Integration (`ChannelHeader.tsx`)

Add a pin icon button to the channel header (right side, before the mobile users button):

- ðŸ“Œ icon button
- On click, call a callback prop `onTogglePins` that the `ChatLayout` handles
- Show a small badge count if there are pinned messages (optional, nice-to-have)

### 6. Frontend â€” ChatLayout State Management (`ChatLayout.tsx`)

Add state management for the pinned messages panel:

- Add `const [showPinnedMessages, setShowPinnedMessages] = useState(false);`
- When `showPinnedMessages` is true, show `<PinnedMessages>` in the right panel area (similar to how thread panel works)
- The pinned messages panel should take priority display alongside or instead of the thread/users panel
- **Simplest approach**: When pins panel is open, show it in the right panel area. When thread is active, thread takes priority. Add a toggle.
- Pass `onTogglePins` callback to `ChannelHeader`
- Close pins panel when switching channels

### 7. Run Codegen and Type Check

After all changes:
```bash
pnpm -s convex codegen
pnpm -s tsc -p tsconfig.json --noEmit
```

Fix any type errors.

### 8. Test with Playwright CLI

Test the following scenarios:
- Pin a message via the hover toolbar
- See the ðŸ“Œ indicator appear on the pinned message
- Open the pinned messages panel from the channel header
- See the pinned message in the panel
- Unpin the message (from hover toolbar or from the panel)
- Verify the pin indicator disappears
- Test on mobile view as well

## File Changes Summary

| File | Action | Description |
|------|--------|-------------|
| `convex/schema.ts` | Edit | Add `pinnedMessages` table |
| `convex/pins.ts` | Create | `pinMessage`, `unpinMessage`, `getPinnedMessages`, `getPinStatus` |
| `src/components/MessageItem.tsx` | Edit | Add pin/unpin button to hover toolbar, pin indicator |
| `src/components/MessageList.tsx` | Edit | Pass pinned message IDs to MessageItem |
| `src/components/PinnedMessages.tsx` | Create | Pinned messages panel component |
| `src/components/ChannelHeader.tsx` | Edit | Add pin icon button |
| `src/components/ChatLayout.tsx` | Edit | State management for pins panel |

## Key Design Decisions

- **Separate table** rather than a `pinned` field on messages â€” cleaner, tracks who pinned and when, easy to query per channel
- **Anyone can pin/unpin** â€” consistent with the app's "everything is open" philosophy
- **Pin status passed from parent** rather than per-message queries â€” much better performance
- **Right panel display** â€” reuses the existing panel pattern established by threads

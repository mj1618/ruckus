# Feature: Full-Text Search Across All Channels

## Overview
Add a global search feature that allows users to search for messages across all channels. Since everything is public in Ruckus, search sees everything. This is a core Phase 4 feature from PLAN.md: "Full-text search across all channels with highlighted matching terms."

Users will access search via a search icon in the channel header or via Ctrl/Cmd+K keyboard shortcut. Results appear in a dedicated search panel showing matching messages with the channel name, author, timestamp, and highlighted matching text. Clicking a result navigates to that channel.

## What to Build

### 1. Schema Change â€” `convex/schema.ts`

Add a full-text search index on the `messages` table:

```typescript
messages: defineTable({
  channelId: v.id("channels"),
  userId: v.id("users"),
  text: v.string(),
  editedAt: v.optional(v.number()),
  parentMessageId: v.optional(v.id("messages")),
  replyCount: v.optional(v.number()),
  latestReplyTime: v.optional(v.number()),
})
  .index("by_channelId", ["channelId"])
  .index("by_parentMessageId", ["parentMessageId"])
  .searchIndex("search_text", {
    searchField: "text",
    filterFields: ["channelId"],
  }),
```

The `.searchIndex("search_text", ...)` adds a full-text search index on the `text` field, with an optional filter by `channelId`. After editing the schema, run `pnpm -s convex codegen` to regenerate types.

### 2. Backend â€” `convex/search.ts` (new file)

Create a new Convex file with a search query:

**`searchMessages` (query)**
- Args: `query: v.string()`, `channelId: v.optional(v.id("channels"))`
- Use the Convex search API: `ctx.db.query("messages").withSearchIndex("search_text", (q) => { let search = q.search("text", args.query); if (args.channelId) search = search.eq("channelId", args.channelId); return search; }).take(30)`
- For each result, fetch the message's user and channel name using `Promise.all`
- Return array of `{ message, user, channelName, channelId }` objects

```typescript
import { v } from "convex/values";
import { query } from "./_generated/server";

export const searchMessages = query({
  args: {
    query: v.string(),
    channelId: v.optional(v.id("channels")),
  },
  handler: async (ctx, args) => {
    if (args.query.trim().length === 0) return [];

    const results = await ctx.db
      .query("messages")
      .withSearchIndex("search_text", (q) => {
        const search = q.search("text", args.query);
        if (args.channelId) {
          return search.eq("channelId", args.channelId);
        }
        return search;
      })
      .take(30);

    // Fetch user and channel info for each result in parallel
    const enriched = await Promise.all(
      results.map(async (message) => {
        const [user, channel] = await Promise.all([
          ctx.db.get("users", message.userId),
          ctx.db.get("channels", message.channelId),
        ]);
        return {
          _id: message._id,
          text: message.text,
          _creationTime: message._creationTime,
          channelId: message.channelId,
          channelName: channel?.name ?? "unknown",
          parentMessageId: message.parentMessageId,
          user: user
            ? { _id: user._id, username: user.username, avatarColor: user.avatarColor }
            : { _id: message.userId, username: "Unknown", avatarColor: "#6b7280" },
        };
      })
    );

    return enriched;
  },
});
```

### 3. Frontend â€” `src/components/SearchPanel.tsx` (new file)

Create a search panel component that appears in the right panel area (same pattern as ThreadPanel and PinnedMessages):

**Props:**
- `onClose: () => void`
- `onNavigateToChannel: (channelId: Id<"channels">) => void` â€” callback to switch channels when clicking a result

**Component structure:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ðŸ” Search       [Ã—]     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Search messages...   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                          â”‚
â”‚  Results (scrollable)    â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ #general             â”‚ â”‚
â”‚ â”‚ user Â· 2:30 PM       â”‚ â”‚
â”‚ â”‚ Message with **term**â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ #random              â”‚ â”‚
â”‚ â”‚ user Â· 1:15 PM       â”‚ â”‚
â”‚ â”‚ Another **match**    â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                          â”‚
â”‚  "No results found"     â”‚
â”‚  (empty state)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Behavior:**
- Text input at the top for the search query, auto-focused
- Debounce input by 300ms before firing the query (use a simple `useState` + `useEffect` with `setTimeout` pattern for debounce)
- Use `useQuery(api.search.searchMessages, debouncedQuery.length > 0 ? { query: debouncedQuery } : "skip")` to fetch results
- Show loading state while results are being fetched
- Each result shows:
  - Channel name as a tag (`#channel-name`) in a small colored chip
  - User avatar (small circle with initial + color), username, and timestamp
  - Message text snippet â€” use `<MessageText>` to render, but truncate long messages to ~200 chars
  - Highlight the matching search terms by wrapping matches in a `<mark>` element with `bg-yellow-500/30 text-yellow-200` styling
- Clicking a result calls `onNavigateToChannel(result.channelId)` to switch to that channel, and closes the panel
- Empty query: show instructional text "Search across all channels"
- No results: show "No messages match your search"
- Style: `w-80` panel with `bg-zinc-900 border-l border-zinc-800`, matching existing panels

**Text highlighting approach:**
Create a simple `highlightText(text: string, query: string)` function that:
1. Splits the query into individual words
2. Creates a regex from the words (case insensitive, escaped for regex)
3. Splits the message text by the regex, wrapping matching segments in `<mark>` elements
4. Returns the React node array
5. Only show the first ~200 characters of the text, adding "..." if truncated

```typescript
function highlightText(text: string, query: string): React.ReactNode {
  if (!query.trim()) return text;
  const words = query.trim().split(/\s+/).map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
  const regex = new RegExp(`(${words.join('|')})`, 'gi');
  const truncated = text.length > 200 ? text.slice(0, 200) + '...' : text;
  const parts = truncated.split(regex);
  return parts.map((part, i) =>
    regex.test(part)
      ? <mark key={i} className="bg-yellow-500/30 text-yellow-200 rounded px-0.5">{part}</mark>
      : part
  );
}
```

### 4. Frontend â€” ChatLayout Integration (`src/components/ChatLayout.tsx`)

Add state and wiring for the search panel:

1. Add state: `const [showSearch, setShowSearch] = useState(false);`
2. When `showSearch` is true, show `<SearchPanel>` in the right panel area, taking priority over online users (but thread panel takes priority over search)
3. Pass `onNavigateToChannel` callback that:
   - Sets the active channel ID
   - Closes the search panel
4. Pass `onToggleSearch` callback to `ChannelHeader`
5. Close search panel when switching channels
6. Add keyboard shortcut: `Ctrl/Cmd+K` to toggle search panel

**Keyboard shortcut implementation:**
Add a `useEffect` in `ChatLayout` that listens for `keydown` events:
```typescript
useEffect(() => {
  function handleKeyDown(e: KeyboardEvent) {
    if ((e.metaKey || e.ctrlKey) && e.key === "k") {
      e.preventDefault();
      setShowSearch((v) => !v);
    }
  }
  window.addEventListener("keydown", handleKeyDown);
  return () => window.removeEventListener("keydown", handleKeyDown);
}, []);
```

**Panel priority in the right panel area (update the existing conditional rendering):**
1. Thread panel (highest priority â€” if `activeThreadId` is set)
2. Pinned messages panel (if `showPinnedMessages` is true)
3. Search panel (if `showSearch` is true)
4. Online users (default fallback)

Update the right panel width: `w-80` when any panel is open (thread, pins, or search), `w-56` for online users only.

Add `"search"` to the `mobileView` union type: `"sidebar" | "chat" | "users" | "thread" | "pins" | "search"`

### 5. Frontend â€” Channel Header Search Button (`src/components/ChannelHeader.tsx`)

Add a search icon button next to the pin button:

- Add a magnifying glass (ðŸ”) icon button
- Add `onToggleSearch: () => void` and `showSearch?: boolean` props to `ChannelHeaderProps`
- Place it before the pin button in the header
- When active, highlight it (same pattern as pins button: `text-indigo-400` when active, `text-zinc-400 hover:text-zinc-200` when inactive)
- Add a small "âŒ˜K" hint text next to or below the button (optional, nice visual cue)

### 6. Run Codegen and Type Check

After all changes:
```bash
pnpm -s convex codegen
pnpm -s tsc -p tsconfig.json --noEmit
```

Fix any type errors.

### 7. Test with Playwright CLI

Test the following scenarios:
- Open search via the header button
- Open search via Ctrl/Cmd+K keyboard shortcut
- Type a search query and see results appear
- Results show channel name, username, timestamp, and highlighted text
- Click a result and verify it navigates to that channel
- Close search with the Ã— button
- Empty state shows appropriate message
- No results shows appropriate message
- Test on mobile view as well (search should work as a full mobile overlay panel)

## File Changes Summary

| File | Action | Description |
|------|--------|-------------|
| `convex/schema.ts` | Edit | Add `.searchIndex("search_text", ...)` to messages table |
| `convex/search.ts` | Create | `searchMessages` query with full-text search |
| `src/components/SearchPanel.tsx` | Create | Search UI panel with input, results, highlighting |
| `src/components/ChatLayout.tsx` | Edit | Add search state, keyboard shortcut, panel rendering |
| `src/components/ChannelHeader.tsx` | Edit | Add search toggle button |

## Key Design Decisions

- **Convex search index** â€” native full-text search, no external search service needed, real-time reactive results
- **Global search (all channels)** â€” consistent with "everything is public" philosophy; optional channel filter for future use
- **Debounced input** â€” avoids hammering the backend on every keystroke
- **Right panel placement** â€” reuses existing panel pattern (thread, pins), familiar UX
- **Ctrl/Cmd+K shortcut** â€” matches PLAN.md spec for quick channel/search switcher, common in modern apps (Slack, VS Code, etc.)
- **Simple text highlighting** â€” split-and-mark approach, efficient and covers the common case well
- **Truncated results** â€” shows first 200 chars to keep results scannable; user clicks to see full message in context
